#include<iostream>
#include<vector>
#include<memory>

#include "CGScheduling.hpp"
#include "MacroNode.hpp"
#include "Pattern.hpp"
#include "Memory.hpp"
#include "OptiMacroNode.hpp"

using namespace std;

MacroNodePriority::MacroNodePriority(int in_mn_idx, CGScheduling* in_sche):mn_idx(in_mn_idx), sche(in_sche){
  mn_idx = in_mn_idx;
  sche = in_sche;

  priority = in_mn_idx;
  //priority = sche->mns[mn_idx]->pred_mns.size();
}

CGScheduling::CGScheduling(ComputationGraph &in_cg, MemoryTrack &in_global_mem):cg(in_cg), global_mem(in_global_mem){
  //cg = in_cg;

  load_latency = 100;
  store_latency = 100;

  //initialize tiles_sche
  for(size_t i=0; i<cg.tiles.size(); i++){
    tile_sche ts;
    ts.start = 0;
    ts.end = 0;
    tiles_sche.push_back(ts);
  }
  //initialize op_in_bank
  for(vector<Tile>::iterator t=cg.tiles.begin(); t!=cg.tiles.end(); t++){
    for(map<int,int>::iterator in_op=t->livein_ops.begin(); in_op!=t->livein_ops.end(); in_op++){
      vector<int> t;
      op_in_bank[in_op->first] = t;
    }
  }

  //initialize memory data
  for(int i=0; i<Memory::num_bank; i++){
    vector<int> t;
    num_port.push_back(t);
    num_live.push_back(t);
  }

  vector<int> ops;
  for(vector<Tile>::iterator t=cg.tiles.begin(); t!=cg.tiles.end(); t++){
    for(map<int,int>::iterator in_op=t->livein_ops.begin(); in_op!=t->livein_ops.end(); in_op++){
      ops.push_back(in_op->first);
    }
    for(vector<int>::iterator out_op=t->liveout_ops.begin(); out_op!=t->liveout_ops.end(); out_op++){
      ops.push_back(*out_op);
    }
  }
  mem = shared_ptr<MemoryTrack>(new MemoryTrack(ops, opti_para));

  begin_cycle = 0;
}

CGScheduling::~CGScheduling(){
  //for(auto it=mns.begin(); it!=mns.end(); it++){
  //  delete *it;
  //}

  //delete mem;
}

void CGScheduling::PrintMacroNodes(){
  cout << endl << "Macro nodes " << endl;
  cout << "------------------------------------------" << endl;
  for(vector<MacroNode*>::iterator mn=mns.begin(); mn!=mns.end(); mn++){
    cout << endl << "mn " << (*mn)->idx << ": " << (*mn)->name << endl;
    cout << "tile map (tile idx in mn: real tile idx)" << endl;
    for(map<int, int>::iterator i=(*mn)->tile_map.begin(); i!=(*mn)->tile_map.end(); i++){
      cout << i->first << ": " << i->second << endl;
    }
    cout << "pred_dblks: ";
    for(auto i=(*mn)->pred_dblks.begin(); i!=(*mn)->pred_dblks.end(); i++){
      cout << *i << " ";
    }
    cout << endl;
    cout << "post_dblks: ";
    for(auto i=(*mn)->post_dblks.begin(); i!=(*mn)->post_dblks.end(); i++){
      cout << *i << " ";
    }
    cout << endl;
  }
  cout << "------------------------------------------" << endl;
}

void CGScheduling::SetMNDep(){
  for(vector<MacroNode*>::iterator mn=mns.begin(); mn!=mns.end(); mn++){

    //set pred_mns of each mn
    for(map<int,int>::iterator inop=(*mn)->mn_temp->inop_firstread.begin(); inop!=(*mn)->mn_temp->inop_firstread.end(); inop++){
      if((*mn)->op_map.find(inop->first) != (*mn)->op_map.end()){
	int real_op = (*mn)->op_map[inop->first];
	//set op_usermn
	if(op_usermn.find(real_op) == op_usermn.end()){
	  set<int> usermn;
	  usermn.insert((*mn)->idx);
	  op_usermn[real_op] = usermn;
	}		 
	else{
	  op_usermn[real_op].insert((*mn)->idx);
	}

	//set mn pred/post mns
	int tile = cg.ops[real_op].tile;
	int pred_mn = cg.tiles[tile].mn;
	if((*mn)->pred_mns.find(pred_mn) == (*mn)->pred_mns.end()){
	  (*mn)->pred_mns.insert(pred_mn);
	  //add mn to pred_mn's post mns
	  mns[pred_mn]->post_mns.insert(mn-mns.begin());
	}
      }
    }
  }
}


//set dependency between mns and dblks
void CGScheduling::SetDep(){
  //generate dblks generated by each mn
  for(auto mn=mns.begin(); mn!=mns.end(); mn++){
    //macronode: mn
    shared_ptr<DataBlock> dblk(new DataBlock(dblks.size()));
    dblks_ptr.push_back(dblk);
    dblks.push_back(dblk.get());

    cout << endl << "dblk " << dblk->idx << " for mn " << (*mn)->idx << endl;
    for(auto t=(*mn)->tile_map.begin(); t!=(*mn)->tile_map.end(); t++){
      int tile = t->first;
      for(auto p=cg.tiles[tile].post_tiles.begin(); p!=cg.tiles[tile].post_tiles.end(); p++){
	for(auto pt=p->second.begin(); pt!=p->second.end(); pt++){
	  if(cg.tiles[*pt].mn != (*mn)->idx){
	    dblk->ops.push_back(p->first);  
	    cout << p->first << endl;
	  }
	}
      }
    }

    (*mn)->post_dblks.push_back(dblk->idx);
    dblk->pred_mns.push_back((*mn)->idx);
  }

  //build dep between dblks and mns
  for(auto dblk=dblks.begin(); dblk!=dblks.end(); dblk++){
    for(auto op=(*dblk)->ops.begin(); op!=(*dblk)->ops.end(); op++){
      for(auto out=cg.ops[*op].out.begin(); out!=cg.ops[*op].out.end(); out++){
        int tile = cg.ops[*out].tile;
	if(tile!=-1){
	  int mn = cg.tiles[tile].mn;
	  if(mn!=-1){
	    if((*dblk)->post_mns.find(mn) == (*dblk)->post_mns.end()){
	      (*dblk)->post_mns.insert(mn);
	      mns[mn]->pred_dblks.push_back((*dblk)->idx);
	    }
	  }
	}
      }
    }
  }
}

void CGScheduling::MacroNodeGen(int blk_dimi, int blk_dimj, int blk_diml){

  vector<vector<int>> mn_dim = {{blk_dimi, blk_diml, 0},
    {blk_diml, blk_dimj, 0},
    {blk_dimi, blk_dimj, blk_diml},
    {blk_dimi, blk_dimj, 0}};

  for(vector<Pattern*>::iterator p=cg.patterns.begin(); p!=cg.patterns.end(); p++){
    cout << endl  << "Generate MacroNode for " << (*p)->name << endl;
    if((*p)->name != "store_matrix"){
      int pattern_idx = p-cg.patterns.begin();
      (*p)->MacroNodeGen(mn_dim[pattern_idx][0], mn_dim[pattern_idx][1], mn_dim[pattern_idx][2]);
      for(auto db=(*p)->dblks.begin(); db!=(*p)->dblks.end(); db++){
	(*db)->idx = dblks.size();
	dblks.push_back(db->get());
      }
      for(auto mn=(*p)->mns.begin(); mn!=(*p)->mns.end(); mn++){
	(*mn)->idx = mns.size();
	mns.push_back(mn->get());
	for(auto t=(*mn)->tile_map.begin(); t!=(*mn)->tile_map.end(); t++){
	  cg.tiles[t->first].mn = (*mn)->idx;
	}
      }
    }
  }

  SetDep();
  PrintDep();
}

void CGScheduling::PrintDep(){
  cout << endl << "Dependency of dblks and mns " << endl;
  for(auto dblk=dblks.begin(); dblk!=dblks.end(); dblk++){
    cout << endl << "dblk " << (*dblk)->idx << endl;
    cout << "pred_mns: ";
    for(auto mn=(*dblk)->pred_mns.begin(); mn!=(*dblk)->pred_mns.end(); mn++){
      cout << mns[*mn]->idx << ",";
    }
    cout << endl;
    cout << "post_mns: ";
    for(auto mn=(*dblk)->post_mns.begin(); mn!=(*dblk)->post_mns.end(); mn++){
      cout << mns[*mn]->idx << ",";
    }
    cout << endl;
  }

  for(auto mn=mns.begin(); mn!=mns.end(); mn++){
    cout << endl << "mn " << (*mn)->idx << endl;
    cout << "pred_dblks: ";
    for(auto db=(*mn)->pred_dblks.begin(); db!=(*mn)->pred_dblks.end(); db++){
      cout << dblks[*db]->idx << ",";
    }
    cout << endl;
    cout << "post_dblks: ";
    for(auto db=(*mn)->post_dblks.begin(); db!=(*mn)->post_dblks.end(); db++){
      cout << dblks[*db]->idx << ",";
    }
    cout << endl;
  }
}


struct mn_comparison{
  bool operator()(const MacroNodePriority* mn1, const MacroNodePriority* mn2){
    if(mn1->priority > mn2->priority){
      return true;
    }
    else{
      return false;
    }
  }
};

void CGScheduling::genMNOrder(vector<int>& order){
  //pattern of mtxmul: cg.patterns[2]
  int mn_m = cg.patterns[2]->mn_m;
  int mn_n = cg.patterns[2]->mn_n;
  int mn_k = cg.patterns[2]->mn_k;

  //row order
  for(int mn_i=0; mn_i<mn_m; mn_i++){
    for(int mn_j=0; mn_j<mn_n; mn_j++){
      for(int mn_l=0; mn_l<mn_k; mn_l++){
        int mn_idx = mn_i*(mn_n*mn_k)+mn_j*mn_k+mn_l;
	order.push_back(mn_idx);
      }
    }
  }
}

void CGScheduling::AllocateDblks(){

  //determine mn order
  genMNOrder(mn_order);

  cout << "mn order" << endl;
  for(auto i=mn_order.begin(); i!=mn_order.end(); i++){
     cout << *i << endl;
  }
  
  //initialize load and store
  for(int c=0; c<mn_order.size(); c++){
    vector<load_dblk> tl;
    load.push_back(tl);
    vector<store_dblk> ts;
    store.push_back(ts);
  }

  //blk need to allocate to mem
  vector<int> a_blk;
  vector<int> b_blk;
  vector<int> c_blk;
  for(auto i=mn_order.begin(); i!=mn_order.end(); i++){
    //mn idx : *i
    a_blk.push_back(mns[*i]->pred_dblks[0]);
    dblks[mns[*i]->pred_dblks[0]]->live_cycle.push_back(i-mn_order.begin());
    b_blk.push_back(mns[*i]->pred_dblks[1]);
    dblks[mns[*i]->pred_dblks[1]]->live_cycle.push_back(i-mn_order.begin());
    c_blk.push_back(mns[*i]->post_dblks[0]);
    dblks[mns[*i]->post_dblks[0]]->live_cycle.push_back(i-mn_order.begin());
    if(mns[*i]->pred_dblks.size() > 2){
      dblks[mns[*i]->pred_dblks[2]]->live_cycle.push_back(i-mn_order.begin());
    }
  }

  cout << "a_blk " << endl;
  for(auto i=a_blk.begin(); i!=a_blk.end(); i++){
    cout << *i << endl;
  }
  cout << "b_blk " << endl;
  for(auto i=b_blk.begin(); i!=b_blk.end(); i++){
    cout << *i << endl;
  }
  cout << "c_blk " << endl;
  for(auto i=c_blk.begin(); i!=c_blk.end(); i++){
    cout << *i << endl;
  }

  //initialize dblks' mem_addr
  for(auto db=dblks.begin(); db!=dblks.end(); db++){
    for(int c=0; c<mn_order.size(); c++){
      (*db)->mem_addr.push_back(-1);
    }
  }
  //sweep all macro cycles

  int num_spill = 0;
  for(int c=0; c<mn_order.size(); c++){
    //allocate c
    //remove c block not live anymore
    for(auto i=global_mem.c.begin(); i!=global_mem.c.end(); i++){
      if(*i != -1){
	if(c > *(dblks[*i]->live_cycle.rbegin())){
	  //store
	  store_dblk t = {*i, global_mem.getBase_c(i-global_mem.c.begin())};
	  store[c-1].push_back(t);
	  *i = -1;
	}
	else{
	  dblks[*i]->mem_addr[c] = global_mem.getBase_c(i-global_mem.c.begin());
	}
      }
    }
    if(dblks[c_blk[c]]->mem_addr[c] == -1){
      for(auto i=global_mem.c.begin(); i!=global_mem.c.end(); i++){
	if(*i == -1){
	  *i = c_blk[c];
	  dblks[c_blk[c]]->mem_addr[c] = global_mem.getBase_c(i-global_mem.c.begin());
	  //load
	  load_dblk t = {c_blk[c], global_mem.getBase_c(i-global_mem.c.begin())};
	  load[c].push_back(t);
	  break;
	}
	else{
	  if(i == (global_mem.c.end()-1)){
	    dblks[*i]->mem_addr[c] = -1;
	    dblks[c_blk[c]]->mem_addr[c] = global_mem.getBase_c(i-global_mem.c.begin());
	    store_dblk ts = {*i, global_mem.getBase_c(i-global_mem.c.begin())};
	    store[c-1].push_back(ts);
	    load_dblk tl = {c_blk[c], global_mem.getBase_c(i-global_mem.c.begin())};
	    load[c].push_back(tl);
	    *i = c_blk[c];

	    cout << "add num_spill, c_space " << global_mem.c_space << endl;
	    num_spill += global_mem.c_space;
	  }
	}
      }
    }
    if(c == mn_order.size()-1){
      for(auto i=global_mem.c.begin(); i!=global_mem.c.end(); i++){
        if(*i != -1){
	  store_dblk t = {*i, global_mem.getBase_c(i-global_mem.c.begin())};
	  store[c].push_back(t);
	}
      }
    }

    //allocate a
    for(auto i=global_mem.a.begin(); i!=global_mem.a.end(); i++){
      if(*i != -1){
        if(c > *(dblks[*i]->live_cycle.rbegin())){
	  *i = -1;
	}
	else{
	  dblks[*i]->mem_addr[c] = global_mem.getBase_a(i-global_mem.a.begin());
	}
      }
    }
    if(dblks[a_blk[c]]->mem_addr[c] == -1){
      for(auto i=global_mem.a.begin(); i!=global_mem.a.end(); i++){
	if(*i == -1){
	  *i = a_blk[c];
	  dblks[a_blk[c]]->mem_addr[c] = global_mem.getBase_a(i-global_mem.a.begin());
	  load_dblk t = {a_blk[c], global_mem.getBase_a(i-global_mem.a.begin())};
	  load[c].push_back(t);
	  break;
	}
	else{
	  if(i == (global_mem.a.end()-1)){
	    dblks[*i]->mem_addr[c] = -1;
	    dblks[a_blk[c]]->mem_addr[c] = global_mem.getBase_a(i-global_mem.a.begin());
	    load_dblk tl = {a_blk[c], global_mem.getBase_a(i-global_mem.a.begin())};
	    load[c].push_back(tl);
	    *i = a_blk[c];

	    cout << "add num_spill, a_space " << global_mem.a_space << endl;
	    num_spill += global_mem.a_space;
	  }
	}
      }
    }

    //allocate b
    for(auto i=global_mem.b.begin(); i!=global_mem.b.end(); i++){
      if(*i != -1){
        if(c > *(dblks[*i]->live_cycle.rbegin())){
	  *i = -1;
	}
	else{
	  dblks[*i]->mem_addr[c] = global_mem.getBase_b(i-global_mem.b.begin());
	}
      }
    }
    if(dblks[b_blk[c]]->mem_addr[c] == -1){
      for(auto i=global_mem.b.begin(); i!=global_mem.b.end(); i++){
	if(*i == -1){
	  *i = b_blk[c];
	  dblks[b_blk[c]]->mem_addr[c] = global_mem.getBase_b(i-global_mem.b.begin());
	  load_dblk t = {b_blk[c], global_mem.getBase_b(i-global_mem.b.begin())};
	  load[c].push_back(t);
	  break;
	}
	else{
	  if(i == (global_mem.b.end()-1)){
	    dblks[*i]->mem_addr[c] = -1;
	    dblks[b_blk[c]]->mem_addr[c] = global_mem.getBase_b(i-global_mem.b.begin());
	    load_dblk tl = {b_blk[c], global_mem.getBase_b(i-global_mem.b.begin())};
	    load[c].push_back(tl);
	    *i = b_blk[c];

	    cout << "add num_spill, b_space " << global_mem.b_space << endl;
	    num_spill += global_mem.b_space;
	  }
	}
      }
    }
  }

  cout << "load dblk " << endl;
  for(int i=0; i<mn_order.size(); i++){
    for(auto t=load[i].begin(); t!=load[i].end(); t++){
      cout << t->dblk_idx << ",";
    }
    cout << endl;
  }

  cout << "store dblk " << endl;
  for(int i=0; i<mn_order.size(); i++){
    for(auto t=store[i].begin(); t!=store[i].end(); t++){
      cout << t->dblk_idx << ",";
    }
    cout << endl;
  }

  //count #spill
  cout << "num spill " << num_spill << endl;


}



void CGScheduling::Scheduling(){
  //schedule each macronode
  //int cycle = 0;
  //num_cycles = 0;
  
  AllocateDblks();

}  

/*
   void CGScheduling::PrintScheduling(){
   cout << "Tile scheduling: " << endl;
   for(vector<tile_sche>::iterator t=tiles_sche.begin(); t!=tiles_sche.end(); t++){
   int tile = t-tiles_sche.begin();
   cout << "tile " << t-tiles_sche.begin() << endl;
   cout << "start " << t->start << endl;
   cout << "end " << t->end << endl;
   for(map<int,int>::iterator i=cg.tiles[tile].livein_ops.begin(); i!=cg.tiles[tile].livein_ops.end(); i++){
   cout << "livein_op " << i->first << " read at " << t->start+i->second << endl;
   }
   for(vector<int>::iterator i=cg.tiles[tile].liveout_ops.begin(); i!=cg.tiles[tile].liveout_ops.end(); i++){
   cout << "liveout_op " << *i << endl;
   }
   cout << endl;
   }
   }

   void CGScheduling::PrintSpill(){
   cout << "Spill scheduling: " << endl;
   for(vector<spill_sche>::iterator sp=spills_sche.begin(); sp!=spills_sche.end(); sp++){
   cout << "spill op " << sp->op << endl;
   cout << "start " << sp->start << " at bank "<< sp->start_membank << endl ;
   cout << "end " << sp->end << " at bank " << sp->end_membank << endl;
   cout << endl;
   }
   }

   void CGScheduling::PrintBankex(){
   cout << "Bankex scheduling: " << endl;
   for(vector<bankex_sche>::iterator bs=bankexs_sche.begin(); bs!=bankexs_sche.end(); bs++){
   cout << "bankex op " << bs->op << endl;
   cout << "start " << bs->start << " at bank " << bs->start_membank << endl;
   cout << "end " << bs->end << " at bank " << bs->end_membank << endl;
   cout << endl;
   }
   }
 */

void CGScheduling::PrintPerf(){
  cout << "number of cycles: " << num_cycles << endl;
  cout << "number of spills: " << spills_sche.size() << endl;
  cout << "number of bankexs: " << bankexs_sche.size() << endl;
  mem->getMaxNumLive();
  cout << "bank usage: ";
  for(int i=0; i<mem->max_num_live.size(); i++){
    cout << mem->max_num_live[i] << ",";
  }
  cout << endl;
}


